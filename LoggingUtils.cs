using System;
using System.Collections.Generic;
using System.IO;
using System.Linq;
using System.Reflection;
using System.Text;
using System.Threading.Tasks;

namespace MusicDatabaseGenerator
{
    public class LoggingUtils
    {
        private StreamWriter skipedDuplicates;
        private StreamWriter filesWithLimitedData;
        private StreamWriter generationLog; //essentially a copy of what is output to the console, for auditting purposes
        private const string loggingPathPrefix = "../../";
        private string skipedDuplicatesPath = $"{loggingPathPrefix}skipped_duplicates.txt";
        private string filesWithLimitedDataPath = $"{loggingPathPrefix}files_with_limited_data.txt";
        private string generationLogPath = $"{loggingPathPrefix}generation.txt";
        private const string _tab = "    ";
        private string header => $"Time (UTC): {DateTime.UtcNow}. Logs generated by the \"Music Database Generator\" (https://github.com/JeffreyGaydos/music-database-generator)";

        public LoggingUtils()
        {
            skipedDuplicates = new StreamWriter(skipedDuplicatesPath);
            filesWithLimitedData = new StreamWriter(filesWithLimitedDataPath);
            generationLog = new StreamWriter(generationLogPath);

            DuplicateLogWriteComment(header);
            LimitedDataLogWriteComment(header);
            GenerationLogWriteComment(header);

            DuplicateLogWriteComment("The following file paths were determined to be duplicates by the generator and were skipped. Consider removing them to save space");
            LimitedDataLogWriteComment("The following file paths have very limited data and cannot be fully used with the generated database. Consider getting .mp3, .flac, .wma, or .m4a versions of the files or add the data yourself.");
        }

        public void DuplicateLogWriteComment(string content)
        {
            skipedDuplicates.WriteLine($"# {content}");
            skipedDuplicates.Flush();
        }

        public void DuplicateLogWriteData(string content)
        {
            skipedDuplicates.WriteLine(content);
            skipedDuplicates.Flush();
        }

        public void LimitedDataLogWriteComment(string content)
        {
            filesWithLimitedData.WriteLine($"# {content}");
            filesWithLimitedData.Flush();
        }

        public void LimitedDataLogWriteData(string content)
        {
            filesWithLimitedData.WriteLine(content);
            filesWithLimitedData.Flush();
        }

        public void GenerationLogWriteComment(string content)
        {
            generationLog.WriteLine($"# {content}");
            generationLog.Flush();
            Console.WriteLine($"# {content}");
        }

        public void GenerationLogWriteData(string content, bool noConsole = false)
        {
            generationLog.WriteLine($"{(noConsole ? _tab : "")}{content}");
            generationLog.Flush();
            if(!noConsole)
                Console.WriteLine(content);
        }

        public void GenerationLogWriteDataSameLine(string content)
        {
            generationLog.Write(content);
            generationLog.Flush();
            Console.Write(content);
        }

        public void Close()
        {
            skipedDuplicates.Close();
            filesWithLimitedData.Close();
            GenerationLogWriteComment($"Generation Completed at {DateTime.UtcNow} (UTC)");
            generationLog.Close();
        }

        private int loadingIncrement;
        private int counter;
        public void LoadingBar(string title, List<string> dataToProcess, Func<string, string> work)
        {
            if(title.Length > 30)
            {
                throw new Exception("Loading bars must have titles that are 30 characters or less so we can effectively line up each bar");
            }
            string titlePadding = new string(' ', 30 - title.Length);
            GenerationLogWriteDataSameLine($"{title}:{titlePadding}");
            
            loadingIncrement = dataToProcess.Count / 50 == 0 ? 1 : dataToProcess.Count / 50;
            counter = 0;

            foreach(string data in dataToProcess)
            {
                work.Invoke(data);
                counter++;
                if (counter % loadingIncrement == 0)
                {
                    GenerationLogWriteDataSameLine("|");
                }
            }
            GenerationLogWriteData("");
        }

        private int _maxLengthForPadding = 100;
        public void GenerationLogWriteWithPaddingBetween2Strings(string log1, string log2)
        {
            string logPadding = log1.Length + log2.Length > _maxLengthForPadding ? " " : new string(' ', _maxLengthForPadding - log1.Length - log2.Length);
            GenerationLogWriteData($"{log1}{logPadding}{log2}");
        }
    }
}
